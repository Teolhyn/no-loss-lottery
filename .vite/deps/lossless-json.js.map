{
  "version": 3,
  "sources": ["../../node_modules/lossless-json/src/config.ts", "../../node_modules/lossless-json/src/utils.ts", "../../node_modules/lossless-json/src/LosslessNumber.ts", "../../node_modules/lossless-json/src/numberParsers.ts", "../../node_modules/lossless-json/src/revive.ts", "../../node_modules/lossless-json/src/parse.ts", "../../node_modules/lossless-json/src/reviveDate.ts", "../../node_modules/lossless-json/src/stringify.ts"],
  "sourcesContent": ["interface ConfigOptional {\n  circularRefs?: boolean\n}\n\ninterface Config extends ConfigOptional {\n  circularRefs: boolean\n}\n\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */\nexport function config(_options?: ConfigOptional): Config {\n  // Backward compatibility warning for v1.x\n  throw new Error(\n    'config is deprecated, support for circularRefs is removed from the library. ' +\n      'If you encounter circular references in your data structures, ' +\n      'please rethink your datastructures: ' +\n      'better prevent circular references in the first place.'\n  )\n}\n", "import type { NumberSplit } from './types'\n\n/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): boolean {\n  if (isInteger(value)) {\n    return Number.isSafeInteger(Number.parseInt(value, 10))\n  }\n\n  const num = Number.parseFloat(value)\n  const parsed = String(num)\n\n  if (value === parsed) {\n    return true\n  }\n\n  const valueDigits = extractSignificantDigits(value)\n  const parsedDigits = extractSignificantDigits(parsed)\n\n  if (valueDigits === parsedDigits) {\n    return true\n  }\n\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14\n    if (\n      !isInteger(value) &&\n      parsedDigits.length >= requiredDigits &&\n      valueDigits.startsWith(parsedDigits.substring(0, requiredDigits))\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport enum UnsafeNumberReason {\n  underflow = 'underflow',\n  overflow = 'overflow',\n  truncate_integer = 'truncate_integer',\n  truncate_float = 'truncate_float'\n}\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value: string): UnsafeNumberReason | undefined {\n  if (isSafeNumber(value, { approx: false })) {\n    return undefined\n  }\n\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer\n  }\n\n  const num = Number.parseFloat(value)\n  if (!Number.isFinite(num)) {\n    return UnsafeNumberReason.overflow\n  }\n\n  if (num === 0) {\n    return UnsafeNumberReason.underflow\n  }\n\n  return UnsafeNumberReason.truncate_float\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): number {\n  const number = Number.parseFloat(value)\n\n  const unsafeReason = getUnsafeNumberReason(value)\n  if (\n    config?.approx === true\n      ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float\n      : unsafeReason\n  ) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '')\n    throw new Error(\n      `Cannot safely convert to number: the value '${value}' would ${unsafeReasonText} and become ${number}`\n    )\n  }\n\n  return number\n}\n\n/**\n * Split a number into sign, digits, and exponent.\n * The value can be constructed again from a split number by inserting a dot\n * at the second character of the digits if there is more than one digit,\n * prepending it with the sign, and appending the exponent like `e${exponent}`\n */\nexport function splitNumber(value: string): NumberSplit {\n  const match = value.match(/^(-?)(\\d+\\.?\\d*)([eE]([+-]?\\d+))?$/)\n  if (!match) {\n    throw new SyntaxError(`Invalid number: ${value}`)\n  }\n\n  const sign = match[1] as '-' | ''\n  const digitsStr = match[2]\n  let exponent = match[4] !== undefined ? Number.parseInt(match[4], 10) : 0\n\n  const dot = digitsStr.indexOf('.')\n  exponent += dot !== -1 ? dot - 1 : digitsStr.length - 1\n\n  const digits = digitsStr\n    .replace('.', '') // remove the dot (must be removed before removing leading zeros)\n    .replace(/^0*/, (zeros: string) => {\n      // remove leading zeros, add their count to the exponent\n      exponent -= zeros.length\n      return ''\n    })\n    .replace(/0*$/, '') // remove trailing zeros\n\n  return digits.length > 0\n    ? { sign, digits, exponent }\n    : { sign, digits: '0', exponent: exponent + 1 }\n}\n\n/**\n * Compare two strings containing a numeric value\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareNumber(a: string, b: string): 1 | 0 | -1 {\n  if (a === b) {\n    return 0\n  }\n\n  const aa = splitNumber(a)\n  const bb = splitNumber(b)\n\n  type Sign = -1 | 1\n\n  const sign: Sign = aa.sign === '-' ? -1 : 1\n\n  if (aa.sign !== bb.sign) {\n    if (aa.digits === '0' && bb.digits === '0') {\n      return 0\n    }\n\n    return sign\n  }\n\n  if (aa.exponent !== bb.exponent) {\n    return aa.exponent > bb.exponent ? sign : aa.exponent < bb.exponent ? (-sign as Sign) : 0\n  }\n\n  return aa.digits > bb.digits ? sign : aa.digits < bb.digits ? (-sign as Sign) : 0\n}\n\n/**\n * Count the significant digits of a number.\n *\n * For example:\n *   '2.34' returns 3\n *   '-77' returns 2\n *   '0.003400' returns 2\n *   '120.5e+30' returns 4\n **/\nexport function countSignificantDigits(value: string): number {\n  const { start, end } = getSignificantDigitRange(value)\n\n  const dot = value.indexOf('.')\n  if (dot === -1 || dot < start || dot > end) {\n    return end - start\n  }\n\n  return end - start - 1\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value: string): string {\n  const { start, end } = getSignificantDigitRange(value)\n\n  const digits = value.substring(start, end)\n\n  const dot = digits.indexOf('.')\n  if (dot === -1) {\n    return digits\n  }\n\n  return digits.substring(0, dot) + digits.substring(dot + 1)\n}\n\n/**\n * Returns the range (start to end) of the significant digits of a value.\n * Note that this range _may_ contain the decimal dot.\n *\n * For example:\n *\n *     getSignificantDigitRange('0.0325900') // { start: 3, end: 7 }\n *     getSignificantDigitRange('2.0300')    // { start: 0, end: 3 }\n *     getSignificantDigitRange('0.0')       // { start: 3, end: 3 }\n *\n */\nfunction getSignificantDigitRange(value: string): { start: number; end: number } {\n  let start = 0\n  if (value[0] === '-') {\n    start++\n  }\n  while (value[start] === '0' || value[start] === '.') {\n    start++\n  }\n\n  let end = value.lastIndexOf('e')\n  if (end === -1) {\n    end = value.lastIndexOf('E')\n  }\n  if (end === -1) {\n    end = value.length\n  }\n  while ((value[end - 1] === '0' || value[end - 1] === '.') && end > start) {\n    end--\n  }\n\n  return { start, end }\n}\n", "import {\n  compareNumber,\n  countSignificantDigits,\n  getUnsafeNumberReason,\n  isInteger,\n  isNumber,\n  UnsafeNumberReason\n} from './utils.js'\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n  value: string\n\n  // type information\n  isLosslessNumber = true\n\n  constructor(value: string) {\n    if (!isNumber(value)) {\n      throw new Error(`Invalid number (value: \"${value}\")`)\n    }\n\n    this.value = value\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf(): number | bigint {\n    const unsafeReason = getUnsafeNumberReason(this.value)\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return Number.parseFloat(this.value)\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value)\n    }\n\n    // overflow or underflow\n    throw new Error(\n      `Cannot safely convert to number: the value '${this.value}' would ${unsafeReason} and become ${Number.parseFloat(this.value)}`\n    )\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString(): string {\n    return this.value\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value: unknown): value is LosslessNumber {\n  // @ts-expect-error\n  return (value && typeof value === 'object' && value.isLosslessNumber) || false\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value: number): LosslessNumber {\n  const maxDigits = 15\n  if (countSignificantDigits(String(value)) > maxDigits) {\n    throw new Error(\n      `Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${value})`\n    )\n  }\n\n  if (Number.isNaN(value)) {\n    throw new Error('Invalid number: NaN')\n  }\n\n  if (!Number.isFinite(value)) {\n    throw new Error(`Invalid number: ${value}`)\n  }\n\n  return new LosslessNumber(String(value))\n}\n\n/**\n * Compare two lossless numbers.\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareLosslessNumber(a: LosslessNumber, b: LosslessNumber): 1 | 0 | -1 {\n  return compareNumber(a.value, b.value)\n}\n", "import { LosslessNumber } from './LosslessNumber.js'\nimport { isInteger } from './utils.js'\n\nexport function parseLosslessNumber(value: string): LosslessNumber {\n  return new LosslessNumber(value)\n}\n\nexport function parseNumberAndBigInt(value: string): number | bigint {\n  return isInteger(value) ? BigInt(value) : Number.parseFloat(value)\n}\n", "import { isLosslessNumber } from './LosslessNumber.js'\nimport type { GenericObject, Reviver } from './types'\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json: unknown, reviver: Reviver): unknown {\n  return reviveValue({ '': json }, '', json, reviver)\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(\n  context: GenericObject<unknown> | Array<unknown>,\n  key: string,\n  value: unknown,\n  reviver: Reviver\n): unknown {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver))\n  }\n\n  if (value && typeof value === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value as GenericObject<unknown>, reviver))\n  }\n\n  return reviver.call(context, key, value)\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object: GenericObject<unknown>, reviver: Reviver) {\n  for (const key of Object.keys(object)) {\n    const value = reviveValue(object, key, object[key], reviver)\n    if (value !== undefined) {\n      object[key] = value\n    } else {\n      delete object[key]\n    }\n  }\n\n  return object\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array: Array<unknown>, reviver: Reviver): Array<unknown> {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, String(i), array[i], reviver)\n  }\n\n  return array\n}\n", "import { parseLosslessNumber } from './numberParsers.js'\nimport { revive } from './revive.js'\nimport type { GenericObject, NumberParser, Reviver } from './types'\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(\n  text: string,\n  reviver?: Reviver | null,\n  parseNumber: NumberParser = parseLosslessNumber\n): unknown {\n  let i = 0\n  const value = parseValue()\n  expectValue(value)\n  expectEndOfInput()\n\n  return reviver ? revive(value, reviver) : value\n\n  function parseObject(): GenericObject<unknown> | undefined {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++\n      skipWhitespace()\n\n      const object: GenericObject<unknown> = {}\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma()\n          skipWhitespace()\n        } else {\n          initial = false\n        }\n\n        const start = i\n\n        const key = parseString()\n        if (key === undefined) {\n          throwObjectKeyExpected()\n          return // To make TS happy\n        }\n\n        skipWhitespace()\n        eatColon()\n        const value = parseValue()\n\n        if (value === undefined) {\n          throwObjectValueExpected()\n          return // To make TS happy\n        }\n\n        // biome-ignore lint/suspicious/noPrototypeBuiltins: TODO: replace with hasOwn one day, when browser support is high enough\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1)\n        }\n\n        object[key] = value\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected()\n      }\n      i++\n\n      return object\n    }\n  }\n\n  function parseArray(): Array<unknown> | unknown {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++\n      skipWhitespace()\n\n      const array = []\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma()\n        } else {\n          initial = false\n        }\n\n        const value = parseValue()\n        expectArrayItem(value)\n        array.push(value)\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected()\n      }\n      i++\n\n      return array\n    }\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace()\n\n    const value =\n      parseString() ??\n      parseNumeric() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n\n    skipWhitespace()\n\n    return value\n  }\n\n  function parseKeyword(name: string, value: unknown): unknown | undefined {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length\n      return value\n    }\n  }\n\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++\n    }\n  }\n\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++\n      let result = ''\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1]\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            result += escapeChar\n            i++\n          } else if (char === 'u') {\n            if (\n              isHex(text.charCodeAt(i + 2)) &&\n              isHex(text.charCodeAt(i + 3)) &&\n              isHex(text.charCodeAt(i + 4)) &&\n              isHex(text.charCodeAt(i + 5))\n            ) {\n              result += String.fromCharCode(Number.parseInt(text.slice(i + 2, i + 6), 16))\n              i += 5\n            } else {\n              throwInvalidUnicodeCharacter(i)\n            }\n          } else {\n            throwInvalidEscapeCharacter(i)\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i]\n          } else {\n            throwInvalidCharacter(text[i])\n          }\n        }\n        i++\n      }\n      expectEndOfString()\n      i++\n      return result\n    }\n  }\n\n  function parseNumeric() {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      expectDigit(start)\n    }\n\n    if (text.charCodeAt(i) === codeZero) {\n      i++\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      return parseNumber(text.slice(start, i))\n    }\n  }\n\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`)\n    }\n    i++\n  }\n\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`)\n    }\n    i++\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`)\n    }\n  }\n\n  function expectArrayItem(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`)\n    }\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i)\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`)\n    }\n  }\n\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`)\n  }\n\n  function throwDuplicateKey(key: string, pos: number) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`)\n  }\n\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`)\n  }\n\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`)\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`)\n  }\n\n  function throwInvalidEscapeCharacter(start: number) {\n    const chars = text.slice(start, start + 2)\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`)\n  }\n\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`)\n  }\n\n  function throwInvalidUnicodeCharacter(start: number) {\n    const chars = text.slice(start, start + 6)\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`)\n  }\n\n  // zero based character position\n  function pos(): string {\n    return `at position ${i}`\n  }\n\n  function got(): string {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input'\n  }\n\n  function gotAt(): string {\n    return `${got()} ${pos()}`\n  }\n}\n\nfunction isWhitespace(code: number): boolean {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn\n}\n\nfunction isHex(code: number): boolean {\n  return (\n    (code >= codeZero && code <= codeNine) ||\n    (code >= codeUppercaseA && code <= codeUppercaseF) ||\n    (code >= codeLowercaseA && code <= codeLowercaseF)\n  )\n}\n\nfunction isDigit(code: number): boolean {\n  return code >= codeZero && code <= codeNine\n}\n\nfunction isNonZeroDigit(code: number): boolean {\n  return code >= codeOne && code <= codeNine\n}\n\nexport function isValidStringCharacter(code: number): boolean {\n  return code >= 0x20 && code <= 0x10ffff\n}\n\nexport function isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]))\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])]\n    return keys.every((key) => isDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\n// map with all escape characters\nconst escapeCharacters: GenericObject<string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nconst codeBackslash = 0x5c // \"\\\"\nconst codeOpeningBrace = 0x7b // \"{\"\nconst codeClosingBrace = 0x7d // \"}\"\nconst codeOpeningBracket = 0x5b // \"[\"\nconst codeClosingBracket = 0x5d // \"]\"\nconst codeSpace = 0x20 // \" \"\nconst codeNewline = 0xa // \"\\n\"\nconst codeTab = 0x9 // \"\\t\"\nconst codeReturn = 0xd // \"\\r\"\nconst codeDoubleQuote = 0x0022 // \"\nconst codePlus = 0x2b // \"+\"\nconst codeMinus = 0x2d // \"-\"\nconst codeZero = 0x30\nconst codeOne = 0x31\nconst codeNine = 0x39\nconst codeComma = 0x2c // \",\"\nconst codeDot = 0x2e // \".\" (dot, period)\nconst codeColon = 0x3a // \":\"\nexport const codeUppercaseA = 0x41 // \"A\"\nexport const codeLowercaseA = 0x61 // \"a\"\nexport const codeUppercaseE = 0x45 // \"E\"\nexport const codeLowercaseE = 0x65 // \"e\"\nexport const codeUppercaseF = 0x46 // \"F\"\nexport const codeLowercaseF = 0x66 // \"f\"\n", "/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nexport function reviveDate(_key: string, value: unknown): Date | unknown {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/\n", "import type { GenericObject, NumberStringifier, Replacer } from './types'\nimport { isNumber } from './utils.js'\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nexport function stringify(\n  value: unknown,\n  replacer?: Replacer | null,\n  space?: number | string,\n  numberStringifiers?: NumberStringifier[]\n): string | undefined {\n  const resolvedSpace = resolveSpace(space)\n\n  const replacedValue =\n    typeof replacer === 'function' ? replacer.call({ '': value }, '', value) : value\n\n  return stringifyValue(replacedValue, '')\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value: unknown, indent: string | undefined): string | undefined {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find((item) => item.test(value))\n      if (stringifier) {\n        const str: unknown = stringifier.stringify(value)\n        if (typeof str !== 'string' || !isNumber(str)) {\n          throw new Error(\n            `Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${str})`\n          )\n        }\n        return str\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (\n      typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      value === null ||\n      value instanceof Date ||\n      value instanceof Boolean ||\n      value instanceof Number ||\n      value instanceof String\n    ) {\n      return JSON.stringify(value)\n    }\n\n    // lossless number, the secret ingredient :)\n    // @ts-expect-error\n    if (value?.isLosslessNumber) {\n      return value.toString()\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString()\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent)\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value as GenericObject<unknown>, indent)\n    }\n\n    return undefined\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array: Array<unknown>, indent: string | undefined): string {\n    if (array.length === 0) {\n      return '[]'\n    }\n\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined\n    let str = resolvedSpace ? '[\\n' : '['\n\n    for (let i = 0; i < array.length; i++) {\n      const item =\n        typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i]\n\n      if (resolvedSpace) {\n        str += childIndent\n      }\n\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent)\n      } else {\n        str += 'null'\n      }\n\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ','\n      }\n    }\n\n    str += resolvedSpace ? `\\n${indent}]` : ']'\n    return str\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(\n    object: GenericObject<unknown>,\n    indent: string | undefined\n  ): string | undefined {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined)\n    }\n\n    const keys: string[] = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object)\n\n    if (keys.length === 0) {\n      return '{}'\n    }\n\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined\n    let first = true\n    let str = resolvedSpace ? '{\\n' : '{'\n\n    for (const key of keys) {\n      const value =\n        typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key]\n\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false\n        } else {\n          str += resolvedSpace ? ',\\n' : ','\n        }\n\n        const keyStr = JSON.stringify(key)\n        str += resolvedSpace ? `${childIndent + keyStr}: ` : `${keyStr}:`\n\n        str += stringifyValue(value, childIndent)\n      }\n    }\n\n    str += resolvedSpace ? `\\n${indent}}` : '}'\n    return str\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(_key: string, value: unknown): boolean {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol'\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space: number | string | undefined): string | undefined {\n  if (typeof space === 'number') {\n    return ' '.repeat(space)\n  }\n\n  if (typeof space === 'string' && space !== '') {\n    return space\n  }\n\n  return undefined\n}\n"],
  "mappings": "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",
  "names": ["config", "_options", "Error", "isInteger", "value", "INTEGER_REGEX", "test", "isNumber", "NUMBER_REGEX", "isSafeNumber", "config", "Number", "isSafeInteger", "parseInt", "num", "parseFloat", "parsed", "String", "valueDigits", "extractSignificantDigits", "parsedDigits", "approx", "requiredDigits", "length", "startsWith", "substring", "UnsafeNumberReason", "getUnsafeNumberReason", "undefined", "truncate_integer", "isFinite", "overflow", "underflow", "truncate_float", "toSafeNumberOrThrow", "number", "unsafeReason", "unsafeReasonText", "replace", "Error", "splitNumber", "match", "SyntaxError", "sign", "digitsStr", "exponent", "dot", "indexOf", "digits", "zeros", "compareNumber", "a", "b", "aa", "bb", "countSignificantDigits", "start", "end", "getSignificantDigitRange", "lastIndexOf", "LosslessNumber", "isLosslessNumber", "constructor", "value", "isNumber", "Error", "valueOf", "unsafeReason", "getUnsafeNumberReason", "undefined", "UnsafeNumberReason", "truncate_float", "Number", "parseFloat", "isInteger", "BigInt", "toString", "toLosslessNumber", "maxDigits", "countSignificantDigits", "String", "isNaN", "isFinite", "compareLosslessNumber", "a", "b", "compareNumber", "parseLosslessNumber", "value", "LosslessNumber", "parseNumberAndBigInt", "isInteger", "BigInt", "Number", "parseFloat", "revive", "json", "reviver", "reviveValue", "context", "key", "value", "Array", "isArray", "call", "reviveArray", "isLosslessNumber", "reviveObject", "object", "Object", "keys", "undefined", "array", "i", "length", "String", "parse", "text", "reviver", "parseNumber", "arguments", "length", "undefined", "parseLosslessNumber", "i", "value", "parseValue", "expectValue", "expectEndOfInput", "revive", "parseObject", "charCodeAt", "codeOpeningBrace", "skipWhitespace", "object", "initial", "codeClosingBrace", "eatComma", "start", "key", "parseString", "throwObjectKeyExpected", "eatColon", "throwObjectValueExpected", "Object", "prototype", "hasOwnProperty", "call", "isDeepEqual", "throwDuplicateKey", "throwObjectKeyOrEndExpected", "parseArray", "codeOpeningBracket", "array", "codeClosingBracket", "expectArrayItem", "push", "throwArrayItemOrEndExpected", "parseNumeric", "parseKeyword", "name", "slice", "isWhitespace", "codeDoubleQuote", "result", "codeBackslash", "char", "escapeChar", "escapeCharacters", "isHex", "String", "fromCharCode", "Number", "parseInt", "throwInvalidUnicodeCharacter", "throwInvalidEscapeCharacter", "isValidStringCharacter", "throwInvalidCharacter", "expectEndOfString", "codeMinus", "expectDigit", "codeZero", "isNonZeroDigit", "isDigit", "codeDot", "codeLowercaseE", "codeUppercaseE", "codePlus", "codeComma", "SyntaxError", "gotAt", "codeColon", "numSoFar", "pos", "chars", "got", "code", "codeSpace", "codeNewline", "codeTab", "codeReturn", "codeNine", "codeUppercaseA", "codeUppercaseF", "codeLowercaseA", "codeLowercaseF", "codeOne", "a", "b", "Array", "isArray", "every", "item", "index", "isObject", "keys", "Set", "f", "n", "r", "t", "reviveDate", "_key", "value", "isoDateRegex", "test", "Date", "stringify", "value", "replacer", "space", "numberStringifiers", "resolvedSpace", "resolveSpace", "replacedValue", "call", "stringifyValue", "indent", "Array", "isArray", "stringifier", "find", "item", "test", "str", "isNumber", "Error", "Date", "Boolean", "Number", "String", "JSON", "isLosslessNumber", "toString", "stringifyArray", "stringifyObject", "undefined", "array", "length", "childIndent", "i", "object", "toJSON", "keys", "map", "Object", "first", "key", "includeProperty", "keyStr", "_key", "repeat"]
}
