{
  "version": 3,
  "sources": ["../../node_modules/@stellar/stellar-xdr-json/stellar_xdr_json.js"],
  "sourcesContent": ["let wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* Returns a list of XDR types.\n* @returns {(string)[]}\n*/\nexport function types() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.types(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_0(r0, r1 * 4, 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n* Returns the JSON Schema for an XDR type.\n*\n* JSON Schema version Draft 7 is returned.\n* @param {string} type_variant\n* @returns {string}\n*/\nexport function schema(type_variant) {\n    let deferred3_0;\n    let deferred3_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(type_variant, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.schema(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        deferred3_0 = ptr2;\n        deferred3_1 = len2;\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_0(deferred3_0, deferred3_1, 1);\n    }\n}\n\n/**\n* Identifies which XDR types the given XDR can decode to completely.\n*\n* Supports single XDR values only, not arrays, streams, or framed streams.\n* @param {string} xdr_base64\n* @returns {(string)[]}\n*/\nexport function guess(xdr_base64) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(xdr_base64, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.guess(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_0(r0, r1 * 4, 4);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Decodes a stream of XDR into an array of JSONs.\n*\n* Returns an array of JSON strings.\n*\n* Returns a JSON string.\n* @param {string} type_variant\n* @param {string} xdr_base64\n* @returns {(string)[]}\n*/\nexport function decode_stream(type_variant, xdr_base64) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(type_variant, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(xdr_base64, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decode_stream(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v3 = getArrayJsValueFromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_0(r0, r1 * 4, 4);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Decodes the XDR into JSON.\n*\n* Accepts a XDR base64 string.\n*\n* Returns a JSON string.\n*\n* Unstable: The API of this function is unstable and will likely be changed to\n* return a JsValue instead of a JSON string.\n* @param {string} type_variant\n* @param {string} xdr_base64\n* @returns {string}\n*/\nexport function decode(type_variant, xdr_base64) {\n    let deferred4_0;\n    let deferred4_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(type_variant, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(xdr_base64, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decode(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr3 = r0;\n        var len3 = r1;\n        if (r3) {\n            ptr3 = 0; len3 = 0;\n            throw takeObject(r2);\n        }\n        deferred4_0 = ptr3;\n        deferred4_1 = len3;\n        return getStringFromWasm0(ptr3, len3);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_0(deferred4_0, deferred4_1, 1);\n    }\n}\n\n/**\n* Encodes to XDR from JSON.\n*\n* Accepts a JSON string.\n*\n* Returns an XDR base64 string.\n*\n* Unstable: The API of this function is unstable and will likely be changed to\n* accept a JsValue instead of a JSON string.\n* @param {string} type_variant\n* @param {string} json\n* @returns {string}\n*/\nexport function encode(type_variant, json) {\n    let deferred4_0;\n    let deferred4_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(type_variant, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(json, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.encode(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr3 = r0;\n        var len3 = r1;\n        if (r3) {\n            ptr3 = 0; len3 = 0;\n            throw takeObject(r2);\n        }\n        deferred4_0 = ptr3;\n        deferred4_1 = len3;\n        return getStringFromWasm0(ptr3, len3);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_0(deferred4_0, deferred4_1, 1);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedInt32Memory0 = null;\n    cachedUint32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL('stellar_xdr_json_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync }\nexport default __wbg_init;\n"],
  "mappings": "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",
  "names": ["ptr"]
}
